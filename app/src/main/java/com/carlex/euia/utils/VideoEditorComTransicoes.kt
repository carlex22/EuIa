// File: euia/utils/VideoEditorComTransicoes.kt
package com.carlex.euia.utils

import android.content.Context
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.util.Log
import com.arthenica.ffmpegkit.*
import android.graphics.BitmapFactory
import com.carlex.euia.data.SceneLinkData
import com.carlex.euia.data.VideoPreferencesDataStoreManager
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import kotlin.math.max
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import java.util.Locale
import java.util.UUID
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.withContext
import kotlin.math.min

/**
 * Editor de v√≠deo focado em:
 * - Criar slideshow a partir de imagens ou usar clipes de v√≠deo (agora usando SceneLinkData).
 * - Adicionar transi√ß√µes (controlado por prefer√™ncia).
 * - Adicionar efeito Ken Burns (zoompan) (controlado por prefer√™ncia).
 * - Mixar √°udio principal (voz) e m√∫sica de fundo.
 * - Adicionar legendas (controlado por prefer√™ncia).
 * - Usar dimens√µes de v√≠deo das prefer√™ncias.
 * - Salvar v√≠deo final no diret√≥rio de prefer√™ncias do projeto.
 */
object VideoEditorComTransicoes {

    private const val TAG = "VideoEditorComTransicoes"
    val tempoTransicaoPadrao = 0.5

    private const val DEFAULT_VIDEO_WIDTH = 720
    private const val DEFAULT_VIDEO_HEIGHT = 1280

    // Fun√ß√£o auxiliar para criar imagem preta (COMO DEFINIDO ACIMA)
    private fun createTemporaryBlackImage(context: Context, width: Int, height: Int, projectDirName: String): String? {
        val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(bitmap)
        canvas.drawColor(Color.BLACK)

        val tempDir = getProjectSpecificDirectory(context, projectDirName, "temp_ffmpeg_assets")
        

        val file = File(tempDir, "black_padding_end_${System.currentTimeMillis()}.png")
        return try {
            FileOutputStream(file).use { out ->
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)
            }
            bitmap.recycle()
            Log.d(TAG, "Imagem preta tempor√°ria criada em: ${file.absolutePath}")
            return file.absolutePath
        } catch (e: IOException) {
            Log.e(TAG, "Erro ao criar imagem preta tempor√°ria: ${e.message}", e)
            bitmap.recycle()
            return null
        }
    }


    suspend fun gerarVideoComTransicoes(
        context: Context,
        scenes: List<SceneLinkData>,
        audioPath: String,
        musicaPath: String,
        legendaPath: String, // Este √© o caminho do arquivo SRT gerado
        logCallback: (String) -> Unit
    ): String {
        Log.d(TAG, "üé¨ Iniciando gerarVideo com ${scenes.size} cenas SceneLinkData")
        require(scenes.isNotEmpty()) { "A lista de cenas n√£o pode estar vazia" }
        // <<<< IN√çCIO DA MODIFICA√á√ÉO >>>>
        val videoPreferencesManager = VideoPreferencesDataStoreManager(context)
        val (projectDirName, larguraVideoPref, alturaVideoPref, enableSubtitlesPref, enableSceneTransitionsPref, enableZoomPanPref, videoFpsPref, videoHdMotionPref) = withContext(Dispatchers.IO) {
            val dirName = videoPreferencesManager.videoProjectDir.first()
            val largura = videoPreferencesManager.videoLargura.first()
            val altura = videoPreferencesManager.videoAltura.first()
            val subtitles = videoPreferencesManager.enableSubtitles.first()
            val transitions = videoPreferencesManager.enableSceneTransitions.first()
            val zoomPan = videoPreferencesManager.enableZoomPan.first()
            val fps = videoPreferencesManager.videoFps.first()
            val hdMotion = videoPreferencesManager.videoHdMotion.first()
            Log.d(TAG, "Prefer√™ncias lidas: Dir=$dirName, LxA=${largura ?: "N/D"}x${altura ?: "N/D"}, Legendas=$subtitles, Transi√ß√µes=$transitions, ZoomPan=$zoomPan, FPS=$fps, HDMotion=$hdMotion")
            Octuple(dirName, largura, altura, subtitles, transitions, zoomPan, fps, hdMotion)
        }

        Log.d(TAG, "Diret√≥rio do projeto para salvar v√≠deo: '$projectDirName'")
        val larguraVideoParaProcessamento = larguraVideoPref ?: DEFAULT_VIDEO_WIDTH
        val alturaVideoParaProcessamento = alturaVideoPref ?: DEFAULT_VIDEO_HEIGHT
        
        
        Log.d(TAG, "Dimens√µes do v√≠deo (LxA): ${larguraVideoParaProcessamento}x${alturaVideoParaProcessamento}")
        Log.d(TAG, "Habilitar Legendas (prefer√™ncia): $enableSubtitlesPref")
        Log.d(TAG, "Habilitar Transi√ß√µes (prefer√™ncia): $enableSceneTransitionsPref")
        Log.d(TAG, "Habilitar ZoomPan (prefer√™ncia): $enableZoomPanPref")
        Log.d(TAG, "FPS do V√≠deo (prefer√™ncia): $videoFpsPref")
        Log.d(TAG, "Habilitar HD Motion (prefer√™ncia): $videoHdMotionPref")
        // <<<< FIM DA MODIFICA√á√ÉO >>>>

        val outputPath = createOutputFilePath(context, "video_final_editado", projectDirName)

        val sceneMediaInputs = mutableListOf<Pair<SceneLinkData, String>>()
        for (scene in scenes) {
            if (scene.imagemGeradaPath != null && scene.tempoInicio != null && scene.tempoFim != null && scene.tempoFim > scene.tempoInicio) {
                val mediaFile = File(scene.imagemGeradaPath)
                if (!mediaFile.exists()) {
                    Log.w(TAG, "Arquivo de m√≠dia base (thumbnail/imagem) n√£o encontrado: ${scene.imagemGeradaPath} para cena ${scene.cena}. Pulando cena.")
                    continue
                }
                if (mediaFile.name.startsWith("Vid_")) {
                    val videoFile = File(mediaFile.parentFile, mediaFile.nameWithoutExtension + ".mp4")
                    if (videoFile.exists()) {
                        sceneMediaInputs.add(Pair(scene, videoFile.absolutePath))
                        Log.d(TAG, "Cena ${scene.cena} usar√° V√çDEO: ${videoFile.absolutePath}")
                    } else {
                        Log.w(TAG, "Arquivo de v√≠deo ${videoFile.absolutePath} n√£o encontrado para thumbnail ${scene.imagemGeradaPath}. Pulando cena ${scene.cena}.")
                    }
                } else {
                    sceneMediaInputs.add(Pair(scene, scene.imagemGeradaPath!!))
                    Log.d(TAG, "Cena ${scene.cena} usar√° IMAGEM: ${scene.imagemGeradaPath}")
                }
            } else {
                Log.w(TAG, "Cena ${scene.cena} inv√°lida (sem m√≠dia ou timing). Pulando.")
            }
        }

        require(sceneMediaInputs.isNotEmpty()) { "Nenhuma cena v√°lida com m√≠dia (imagem ou v√≠deo) e timing encontrada para gerar o v√≠deo." }

        // Transformar para listas imut√°veis para o restante do processamento,
        // mas declar√°-las como 'var' para que possam ser reatribu√≠das ap√≥s adicionar a cena preta.
        var finalValidScenesOriginal = sceneMediaInputs.map { it.first }
        var finalMediaPathsOriginal = sceneMediaInputs.map { it.second }
        var duracaoCenasOriginal = finalValidScenesOriginal.map { it.tempoFim!! - it.tempoInicio!! }

        // --- IN√çCIO DA L√ìGICA PARA ADICIONAR CENA PRETA ---
        var blackImagePathTemporary: String? = null // Para limpar depois
        if (finalMediaPathsOriginal.isNotEmpty()) {
            val lastMediaPath = finalMediaPathsOriginal.last()
            val isLastSceneVideo = File(lastMediaPath).name.endsWith(".mp4", ignoreCase = true)

            if (isLastSceneVideo) {
                logCallback("√öltima cena √© um v√≠deo. Adicionando cena preta de 1s no final.")
                Log.i(TAG, "√öltima cena real √© um v√≠deo. Tentando adicionar cena preta de preenchimento.")

                blackImagePathTemporary = createTemporaryBlackImage(
                    context,
                    larguraVideoParaProcessamento,
                    alturaVideoParaProcessamento,
                    projectDirName
                )

                if (blackImagePathTemporary != null) {
                    val lastActualSceneEndTime = finalValidScenesOriginal.lastOrNull()?.tempoFim ?: duracaoCenasOriginal.sum()

                    val blackPaddingScene = SceneLinkData(
                        id = UUID.randomUUID().toString(),
                        cena = "BLACK_PADDING_END",
                        tempoInicio = lastActualSceneEndTime, // Informativo
                        tempoFim = lastActualSceneEndTime + tempoTransicaoPadrao, // Informativo
                        imagemReferenciaPath = blackImagePathTemporary, // Para consist√™ncia, mas n√£o √© uma "refer√™ncia"
                        descricaoReferencia = "Preenchimento preto final",
                        promptGeracao = null,
                        imagemGeradaPath = blackImagePathTemporary, // Caminho para a imagem preta
                        similaridade = null,
                        aprovado = true, // Aprovada por padr√£o
                        exibirProduto = false,
                        isGenerating = false,
                        isChangingClothes = false,
                        generationAttempt = 0,
                        clothesChangeAttempt = 0
                    )
                    // Atualiza as listas para incluir a cena preta
                    finalValidScenesOriginal = finalValidScenesOriginal + blackPaddingScene
                    finalMediaPathsOriginal = finalMediaPathsOriginal + blackImagePathTemporary
                    duracaoCenasOriginal = duracaoCenasOriginal + tempoTransicaoPadrao // Adiciona 1 segundo de dura√ß√£o
                    Log.i(TAG, "Cena preta adicionada. Novo total de m√≠dias: ${finalMediaPathsOriginal.size}")
                } else {
                    logCallback("Falha ao criar imagem preta tempor√°ria. V√≠deo ser√° gerado sem preenchimento extra.")
                    Log.w(TAG, "N√£o foi poss√≠vel criar a imagem preta tempor√°ria.")
                }
            }
        }
        // --- FIM DA L√ìGICA PARA ADICIONAR CENA PRETA ---

        // <<< IN√çCIO DA NOVA L√ìGICA DE CONVERS√ÉO SRT para ASS >>>
        var finalLegendaFilePath: String = "" // Caminho para o arquivo ASS tempor√°rio
        var tempAssFile: File? = null // Vari√°vel para rastrear o arquivo ASS tempor√°rio para limpeza

        if (enableSubtitlesPref && legendaPath.isNotBlank()) {
            val srtFile = File(legendaPath)
            if (srtFile.exists()) {
                try {
                    val srtContent = srtFile.readText()
                    
                    // <<< CHAMADA DO CONVERSOR COM TODOS OS NOVOS PAR√ÇMETROS >>>
                    val assConverter = SrtToAssConverter(
                        // Cores
                        primaryColor = "&H00FFFFFF", // Branco
                        outlineColor = "&H00000000", // Preto
                        shadowColor = "&H80000000",  // Preto 50% transparente

                        // Flags de Efeito
                        enableFadeEffect = true,
                        enableZoomInEffect = true,
                        enableTiltEffect = true,
                        
                        // Tamanhos/Valores de Estilo e Posi√ß√£o
                        outlineSizePixels = 2,
                        shadowOffsetPixels = 4,
                        fontSizeBaseMultiplier = 0.14f, // Base para o c√°lculo din√¢mico da fonte
                        textBlockWidthPercentage = 80, // Largura que o bloco de texto deve ocupar

                        // Par√¢metros de Alinhamento Vertical
                        fixedCenterYRatio = 0.85f, // Ponto fixo para o centro da legenda (85% da altura do v√≠deo)
                        fixedCenterYRatioInImage = 0.90f, // Ponto fixo para o centro da legenda dentro da imagem (90% da altura da imagem vis√≠vel)

                        // Par√¢metros de Anima√ß√£o
                        tiltAngleDegrees = 5,
                        tiltAnimationDurationMs = 150,
                        zoomInAnimationDurationMs = 200,
                        zoomOutAnimationDurationMs = 200,
                        initialZoomScalePercentage = 80,
                        fadeDurationMs = 100,

                        // NOVOS PAR√ÇMETROS PARA CONTROLE DE FONTE DIN√ÇMICA
                        minFontSizeRatio = 0.14f, 
                        maxFontSizeRatio = 0.25f, 
                        idealCharsForScaling = 12,
                        marginInferior = 0.15
                    )
                    
                    val assContent = assConverter.convertSrtToAss(
                        srtContent = srtContent,
                        videoWidth = larguraVideoParaProcessamento,
                        videoHeight = alturaVideoParaProcessamento
                    )
                    // <<< FIM DA CHAMADA >>>

                    // Salvar o conte√∫do ASS em um novo arquivo tempor√°rio .ass
                    val tempAssDir = getProjectSpecificDirectory(context, projectDirName, "temp_ffmpeg_assets")
                    if (tempAssDir == null) {
                        Log.e(TAG, "Falha ao criar diret√≥rio tempor√°rio para ASS. Gerando v√≠deo sem legendas.")
                        logCallback("‚ùå Erro interno: n√£o foi poss√≠vel criar diret√≥rio para legendas ASS. Gerando sem legendas.")
                        finalLegendaFilePath = ""
                    } else {
                        val uniqueAssFileName = "temp_legenda_${UUID.randomUUID()}.ass"
                        tempAssFile = File(tempAssDir, uniqueAssFileName)
                        tempAssFile.writeText(assContent)
                        finalLegendaFilePath = tempAssFile.absolutePath
                        Log.i(TAG, "Legenda SRT convertida para ASS e salva temporariamente em: $finalLegendaFilePath")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Erro ao converter SRT para ASS ou salvar arquivo tempor√°rio: ${e.message}", e)
                    logCallback("‚ùå Erro ao preparar legendas. Gerando v√≠deo sem legendas. Detalhes: ${e.message}")
                    finalLegendaFilePath = "" // Garante que nenhuma legenda seja usada se a convers√£o falhar
                }
            } else {
                Log.w(TAG, "Arquivo de legenda SRT n√£o encontrado em: $legendaPath. N√£o ser√£o usadas legendas.")
                logCallback("‚ö†Ô∏è Arquivo de legenda SRT n√£o encontrado. Gerando v√≠deo sem legendas.")
                finalLegendaFilePath = ""
            }
        } else {
            Log.d(TAG, "Legendas desabilitadas ou caminho da legenda vazio. N√£o ser√£o usadas legendas.")
            finalLegendaFilePath = ""
        }
        // <<< FIM DA NOVA L√ìGICA DE CONVERS√ÉO SRT para ASS >>>

        Log.d(TAG, "üñºÔ∏è M√≠dias FINAIS para FFmpeg (${finalMediaPathsOriginal.size}): ${finalMediaPathsOriginal.joinToString { File(it).name }}")
        Log.d(TAG, "‚è±Ô∏è Dura√ß√µes Cenas FINAIS (s) para FFmpeg: $duracaoCenasOriginal")
        Log.d(TAG, "üîä √Åudio principal: $audioPath")
        Log.d(TAG, "üéµ M√∫sica: $musicaPath")
        Log.d(TAG, "üìù Legenda original: $legendaPath, Legenda ajustada para uso: $finalLegendaFilePath (Usar legendas no v√≠deo: $enableSubtitlesPref)")

        finalMediaPathsOriginal.forEach {
            if (!File(it).exists()) throw IllegalArgumentException("Arquivo de m√≠dia n√£o encontrado: $it")
        }
        if (!File(audioPath).exists()) throw IllegalArgumentException("√Åudio principal n√£o encontrado: $audioPath")
        if (musicaPath.isNotBlank() && !File(musicaPath).exists()) throw IllegalArgumentException("M√∫sica de fundo n√£o encontrada: $musicaPath")

        // Agora, a verifica√ß√£o de exist√™ncia do arquivo de legenda deve ser feita para o `finalLegendaFilePath`
        if (enableSubtitlesPref && finalLegendaFilePath.isNotBlank() && !File(finalLegendaFilePath).exists()) {
            throw IllegalArgumentException("Arquivo de legenda ajustada '$finalLegendaFilePath' n√£o encontrado, mas legendas est√£o habilitadas.")
        }

        val fonteArialPath = try {
            copiarFonteParaCache(context, "Arial.ttf")
        } catch (e: Exception) {
            Log.e(TAG, "Falha cr√≠tica ao preparar fonte: ${e.message}")
            throw RuntimeException("N√£o foi poss√≠vel preparar a fonte necess√°ria para legendas.", e)
        }

        val startTime = System.currentTimeMillis()

        val comandoFFmpeg = buildFFmpeg(
            mediaPaths = finalMediaPathsOriginal, // Usa a lista potencialmente modificada
            duracaoCenas = duracaoCenasOriginal,   // Usa a lista potencialmente modificada
            audioPath = audioPath,
            musicaPath = musicaPath,
            legendaPath = finalLegendaFilePath, // Passa o caminho do arquivo ASS tempor√°rio
            outputPath = outputPath,
            fonteArialPath = fonteArialPath,
            usarLegendas = enableSubtitlesPref,
            usarTransicoes = enableSceneTransitionsPref,
            usarZoomPan = enableZoomPanPref,
            larguraVideoPreferida = larguraVideoPref, // Passa a prefer√™ncia original
            alturaVideoPreferida = alturaVideoPref,     // Passa a prefer√™ncia original
            fps = videoFpsPref, // <<<< NOVO
            hdMotion = videoHdMotionPref // <<<< NOVO
        )
        Log.d(TAG, "üõ†Ô∏è Comando FFmpeg:\n$comandoFFmpeg")

        return suspendCancellableCoroutine { cont ->
            Log.i(TAG, "üöÄ Iniciando execu√ß√£o do FFmpeg...")
            val session = FFmpegKit.executeAsync(comandoFFmpeg, { completedSession ->
                // Limpa a imagem preta tempor√°ria SE ELA FOI CRIADA
                blackImagePathTemporary?.let {
                    val tempFile = File(it)
                    if (tempFile.exists()) {
                        if (tempFile.delete()) {
                            Log.i(TAG, "Imagem preta tempor√°ria ($it) exclu√≠da.")
                        } else {
                            Log.w(TAG, "Falha ao deletar imagem preta tempor√°ria ($it).")
                        }
                    }
                }

                // <<< IN√çCIO DA LIMPEZA DO ARQUIVO ASS TEMPOR√ÅRIO >>>
                tempAssFile?.let { file ->
                    if (file.exists()) {
                        if (file.delete()) {
                            Log.i(TAG, "Arquivo ASS tempor√°rio deletado: ${file.name}")
                        } else {
                            Log.w(TAG, "Falha ao deletar arquivo ASS tempor√°rio: ${file.name}")
                        }
                    }
                }
                // <<< FIM DA LIMPEZA DO ARQUIVO ASS TEMPOR√ÅRIO >>>

                val returnCode = completedSession.returnCode
                val logs = completedSession.allLogsAsString
                val timeElapsed = (System.currentTimeMillis() - startTime) / 1000.0

                if (ReturnCode.isSuccess(returnCode)) {
                    //logCallback("‚úÖ FFmpeg executado com SUCESSO em ${"%.2f".format(Locale.US, timeElapsed)}s.")
                    val outFile = File(outputPath)
                    if (outFile.exists() && outFile.length() > 100) {
                        //logCallback("Arquivo de sa√≠da verificado: $outputPath (Tamanho: ${outFile.length()} bytes)")
                        cont.resume(outputPath)
                    } else {
                        val reason = if (!outFile.exists()) "n√£o foi encontrado" else "est√° vazio ou muito pequeno (${outFile.length()} bytes)"
                        logCallback("‚ùå FFmpeg reportou sucesso, mas o arquivo de sa√≠da '$outputPath' $reason.")
                        Log.e(TAG, "--- Logs Completos (Sucesso Aparente, Arquivo Inv√°lido) --- \n$logs\n --- Fim dos Logs ---")
                        cont.resumeWithException(VideoGenerationException("FFmpeg sucesso aparente, mas arquivo final inv√°lido ($reason). Logs:\n$logs"))
                    }
                } else {
                    logCallback("‚ùå FFmpeg FALHOU com c√≥digo de retorno: $returnCode (Tempo: ${"%.2f".format(Locale.US, timeElapsed)}s)")
                    Log.e(TAG, "--- Logs Completos da Falha --- \n$logs\n --- Fim dos Logs ---")
                    File(outputPath).delete() // Tenta deletar o arquivo de sa√≠da parcial em caso de falha
                    cont.resumeWithException(VideoGenerationException("Falha na execu√ß√£o do FFmpeg (C√≥digo: $returnCode). Logs:\n$logs"))
                }
            }, { log ->
                 logCallback(log.message)
                 Log.v(TAG, "FFmpegLog: ${log.message}")
               },
               { stat ->
                 val statMessage = "üìä FFmpeg Stats: Tempo=${stat.time}ms, Tamanho=${stat.size}, Taxa=${"%.2f".format(Locale.US, stat.bitrate)}, Vel=${"%.2f".format(Locale.US, stat.speed)}x"
                 Log.d(TAG, statMessage)
               })

            cont.invokeOnCancellation {
                Log.w(TAG,"üö´ Opera√ß√£o FFmpeg cancelada!")
                logCallback("üö´ Opera√ß√£o FFmpeg cancelada!")
                FFmpegKit.cancel(session.sessionId)
                // Limpa a imagem preta tempor√°ria tamb√©m em caso de cancelamento
                blackImagePathTemporary?.let {
                    val tempFile = File(it)
                    if (tempFile.exists()) tempFile.delete()
                }
                // <<< IN√çCIO DA LIMPEZA DO ARQUIVO ASS TEMPOR√ÅRIO EM CASO DE CANCELAMENTO >>>
                tempAssFile?.let { file ->
                    if (file.exists()) file.delete()
                }
                // <<< FIM DA LIMPEZA DO ARQUIVO ASS TEMPOR√ÅRIO EM CASO DE CANCELAMENTO >>>
            }
        }
    }
    
    fun Double.format(digits: Int): String = String.format("%.${digits}f", this)


    
   

private fun buildFFmpeg(
    mediaPaths: List<String>,
    duracaoCenas: List<Double>,
    audioPath: String,
    musicaPath: String,
    legendaPath: String, // Este agora ser√° o caminho para o arquivo ASS
    outputPath: String,
    fonteArialPath: String,
    usarLegendas: Boolean,
    usarTransicoes: Boolean,
    usarZoomPan: Boolean,
    larguraVideoPreferida: Int?,
    alturaVideoPreferida: Int?,
    fps: Int,
    hdMotion: Boolean
): String {
    val cmd = StringBuilder("-y -hide_banner ")
    val filterComplex = StringBuilder()
    val larguraFinalVideo = (larguraVideoPreferida ?: DEFAULT_VIDEO_WIDTH).coerceAtLeast(100)
    val alturaFinalVideo = (alturaVideoPreferida ?: DEFAULT_VIDEO_HEIGHT).coerceAtLeast(100)
    Log.i(TAG, "FFmpeg VIDEO ${larguraFinalVideo}x${alturaFinalVideo} | FPS: $fps | HD Motion: $hdMotion | Transi√ß√µes: $usarTransicoes | ZoomPan: $usarZoomPan | Legendas: $usarLegendas")
    val tempoDeTransicaoEfetivo = if (usarTransicoes && mediaPaths.size > 1) tempoTransicaoPadrao else 0.0
    
    // Apenas a fonte para as legendas, n√£o precisa do `legendaPath` aqui.
    val fonteDir = File(fonteArialPath).parent?.replace("\\", "/")?.replace(":", "\\\\:") ?: "."
    val fonteNome = File(fonteArialPath).nameWithoutExtension
    
    var inputIndex = 0
    if (musicaPath.isNotBlank()) {
        cmd.append("-i \"$musicaPath\" ")
        inputIndex++
    }
    val mediaInputStartIndex = inputIndex
    var ii=0
    mediaPaths.forEachIndexed { index, path ->
        val isVideoInput = path.endsWith(".mp4", true) || path.endsWith(".webm", true)
        val duracaoDestaCena = duracaoCenas[index]
        val isLast = (index == mediaPaths.lastIndex)
        val inputDurationParaComando =
            if (isVideoInput) duracaoDestaCena
            else duracaoDestaCena + if (!isLast) tempoDeTransicaoEfetivo else 0.0
        if (isVideoInput) {
            Log.d(TAG, "Cena MidiaAdd $ii | duracaoDestaCena: %.2f".format(duracaoDestaCena))
            cmd.append(String.format(Locale.US, "-stream_loop -1 -t %.4f -i \"%s\" -an ", duracaoDestaCena, path))
        } else {
            Log.d(TAG, "Cena MidiaAdd $ii | inputDurationParaComando: %.4f".format(inputDurationParaComando))
            cmd.append(String.format(Locale.US, "-loop 1 -r %d -t %.4f -i \"%s\" ", fps, inputDurationParaComando, path))
        }
        ii++
        inputIndex++
    }
    val audioInputIndex = inputIndex
    cmd.append("-i \"$audioPath\" ")
    
    
    
    // Filtros de v√≠deo
    filterComplex.append("\n")
    val processedMediaPads = mutableListOf<String>()
    mediaPaths.forEachIndexed { i, path ->
        val outputPad = "[processed_m$i]"
        processedMediaPads.add(outputPad)

        val isVideo = path.endsWith(".mp4", true) || path.endsWith(".webm", true)
        val durBase = duracaoCenas[i]
        val isLast = (i == mediaPaths.lastIndex)
        val trim = durBase + (if (!isLast && usarTransicoes) tempoDeTransicaoEfetivo else 0.0)
        
        val frames = (trim * fps).toInt().coerceAtLeast(1)
        val durationExata = frames.toDouble() / fps
        val w = larguraFinalVideo
        val h = alturaFinalVideo
        val input = "[${i + mediaInputStartIndex}:v]"

        // --- IN√çCIO DA NOVA L√ìGICA DE COMPOSI√á√ÉO DE FRAME ---
        
        // 1. Divide o stream de entrada para processar fundo e frente separadamente
        filterComplex.append("  ${input}split=2[main${i}][bg${i}];\n")

        // 2. Cria o fundo desfocado e ampliado
        filterComplex.append("  [bg${i}]scale='max(iw,${w}*2)':'max(ih,${h}*2)',crop=${w}:${h},boxblur=40:2,setsar=1[bg_final${i}];\n")

        // 3. Processa a imagem/v√≠deo da frente
        
        var squareDix = w
        var squareDiy = h
        var ss = "${w}x${h}"
        
        if (w>h){
           squareDix = (squareDiy * 1.2).toInt()
            ss = "${squareDix}x${squareDiy}"
        } else if (w<h){
            squareDiy = (squareDix * 1.2).toInt()
            ss = "${squareDix}y${squareDiy}"
        }
        
        if (isVideo) {
            // Para v√≠deos, aplica letterbox/pillarbox para caber no quadro quadrado
            filterComplex.append("[main${i}]scale=$squareDix:$squareDiy:force_original_aspect_ratio=decrease[fg_scaled${i}];\n")
        } else {
            // Para imagens, aplica o zoompan primeiro (se habilitado), depois corta para o quadrado
            val fgChain = mutableListOf<String>()
            if (usarZoomPan) {
                val (zoomExpr, xExpr, yExpr) = gerarZoompanExpressao(path, squareDix, squareDiy, frames, i)
                fgChain.add("scale=${squareDix}:${squareDiy}:force_original_aspect_ratio=decrease,"
                          + "pad=${squareDix}:${squareDiy}:(ow-iw)/2:(oh-ih)/2:color=black," 
                          + "setsar=1,"
                          + "zoompan=z=$zoomExpr:s=${ss}:d=$frames:x=$xExpr:y=$yExpr:fps=$fps")
            }
            fgChain.add("crop=$squareDix:$squareDiy")
             if (hdMotion) {
                fgChain.add("minterpolate=fps=$fps:mi_mode=mci:mc_mode=aobmc:vsbmc=1")
            }
            filterComplex.append("  [main${i}]${fgChain.joinToString(",")}[fg_scaled${i}];\n")
        }

        // 4. Cria o quadro composto (frente + fundo)
        // Primeiro, o pad da frente para ter o tamanho final do v√≠deo com fundo transparente
        filterComplex.append("  [fg_scaled${i}]pad=${w}:${h}:(ow-iw)/2:(oh-ih)/2:color=black@0.0[fg_padded${i}];\n")
        // Depois, sobrep√µe a frente com pad sobre o fundo
        filterComplex.append("  [bg_final${i}][fg_padded${i}]overlay=0:0[composite${i}];\n")

        
        // 5. Adiciona os filtros finais de dura√ß√£o e timestamp
        val finalEffects = mutableListOf<String>()
        finalEffects.add("format=pix_fmts=rgba") 
        finalEffects.add("fps=$fps")            
        finalEffects.add("trim=duration=$durationExata")
        finalEffects.add("setpts=PTS-STARTPTS")

        filterComplex.append("  [composite${i}]${finalEffects.joinToString(separator = ",")}$outputPad;\n")
    }



    val tiposDeTransicao = listOf(
        "fade", 
        //"slideleft", "slideright", 
        "slidedown",
        "circleopen", "circleclose", 
        "rectcrop", "distance", 
        "fadeblack", "fadewhite", 
        //"dissolve", 
        //"wipeleft", "wiperight"
    )


    val random = java.util.Random()

val videoStreamFinal: String = when {
    usarTransicoes && processedMediaPads.size > 1 -> {
        processedMediaPads.forEachIndexed { index, padName ->
            filterComplex.append("  $padName setpts=PTS-STARTPTS[sc_trans$index];\n")
        }
        var currentStream = "[sc_trans0]"
        var durationOfCurrentStream = duracaoCenas[0]
        for (i in 0 until processedMediaPads.size - 1) {
            val nextSceneStream = "[sc_trans${i + 1}]"
            val nextSceneOriginalDuration = duracaoCenas[i+1] - tempoDeTransicaoEfetivo
            val xfadeOutputStreamName = if (i == processedMediaPads.size - 2) "[vc_final_effect]" else "[xfade_out_trans$i]"
            val xfadeOffset = max(0.0, durationOfCurrentStream)

            // Escolhe aleatoriamente um tipo de transi√ß√£o para esta mudan√ßa de cena
            val tipoTransicao = tiposDeTransicao[random.nextInt(tiposDeTransicao.size)]

            filterComplex.append(
                "  $currentStream$nextSceneStream xfade=transition=$tipoTransicao:duration=$tempoDeTransicaoEfetivo:offset=$xfadeOffset$xfadeOutputStreamName;\n"
            )
            currentStream = xfadeOutputStreamName
            durationOfCurrentStream = durationOfCurrentStream + nextSceneOriginalDuration + tempoDeTransicaoEfetivo
            durationOfCurrentStream = max(0.1, durationOfCurrentStream)
            Log.i(TAG, "Cena $i Transicao| tipo=$tipoTransicao | durationOfCurrentStream: %.2f".format(durationOfCurrentStream))
        }
        currentStream
    }
    processedMediaPads.isNotEmpty() && processedMediaPads.size > 1 -> {
        processedMediaPads.forEachIndexed { index, pad ->
            filterComplex.append("  $pad setpts=PTS-STARTPTS[s_concat$index];\n")
        }
        val concatInputs = processedMediaPads.indices.joinToString("") { "[s_concat$it]" }
        filterComplex.append("  $concatInputs concat=n=${processedMediaPads.size}:v=1:a=0[vc_final_effect];\n")
        "[vc_final_effect]"
    }
    processedMediaPads.isNotEmpty() -> {
        filterComplex.append("  ${processedMediaPads[0]} copy[vc_final_effect];\n")
        "[vc_final_effect]"
    }
    else -> {
        val totalDurationFallback = duracaoCenas.sum().takeIf { it > 0.0 } ?: 1.0
        filterComplex.append("color=c=black:s=${larguraFinalVideo}x${alturaFinalVideo}:d=${max(0.1, totalDurationFallback)}[vc_final_effect];\n")
        "[vc_final_effect]"
    }
}


    // Legendas (usando o caminho do arquivo ASS, se definido)
    val videoComLegendasPad: String =
        if (usarLegendas && legendaPath.isNotBlank()) {
            val escapedLegendaPath = legendaPath.replace("'", "'\\''") // Escapa aspas simples
                .replace("\\", "/") // Normaliza barras (Windows para Unix-like)
                .replace(":", "\\\\:") // Escapa dois pontos (para paths em Windows)

            filterComplex.append("  $videoStreamFinal subtitles=filename='$escapedLegendaPath'")
            filterComplex.append(":fontsdir='$fonteDir'")
            // Ao usar ASS, o estilo √© definido NO ARQUIVO ASS. O force_style aqui deve ser m√≠nimo para n√£o sobrescrever o ASS.
            // Apenas definimos Alignment e Margins se necess√°rio, para garantir consist√™ncia ou corrigir falhas no ASS.
            // Para efeitos avan√ßados, √© crucial que o estilo venha do ASS, n√£o do FFmpeg `force_style`.
            // O filtro `subtitles` l√™ o estilo do .ass, ent√£o podemos remover a maioria dos par√¢metros daqui.
            // Podemos manter Alignment e Margins se quisermos um fallback ou ajuste final universal.
            // Remover `FontName` daqui, pois ele j√° est√° no ASS.
            filterComplex.append(":force_style='Alignment=2'") // Ajustado para ser menos intrusivo
            filterComplex.append("[v_out];\n")
            "[v_out]"
        } else {
            filterComplex.append("  $videoStreamFinal copy[v_out];\n")
            "[v_out]"
        }

    // √Åudio
    val audioPrincipalInputString = "[$audioInputIndex:a]"
    filterComplex.append("  $audioPrincipalInputString volume=1.0[voice];\n")

    if (musicaPath.isNotBlank()) {
        val musicaInputString = "[0:a]"
        filterComplex.append("  $musicaInputString volume=0.18,adelay=500|500[bgm];\n")
        filterComplex.append("  [voice][bgm]amix=inputs=2:duration=first:dropout_transition=3[a_out];\n")
    } else {
        filterComplex.append("  [voice]acopy[a_out];\n")
    }

    // Finaliza√ß√£o do filter_complex
    cmd.append("-filter_complex \"${filterComplex}\" ")
    cmd.append("-map \"$videoComLegendasPad\" -map \"[a_out]\" ")
    // N√ÉO use -r 30 aqui! O FPS j√° est√° travado l√° em cima, para n√£o gerar drop/double frames!
    //cmd.append("-c:v libx264 -preset veryfast -crf 23 -pix_fmt yuv420p ")
    cmd.append("-c:v libx264 -preset veryfast -crf 23 -pix_fmt yuv420p -r $fps ")
    cmd.append("-movflags +faststart ")
    val duracaoTotalVideoCalculada =
        duracaoCenas.sum() + (if (usarTransicoes && mediaPaths.size > 1) (mediaPaths.size - 1) * tempoDeTransicaoEfetivo else 0.0)
    cmd.append(String.format(Locale.US, "-t %.4f ", max(0.1, duracaoTotalVideoCalculada)))
    cmd.append("\"$outputPath\"")
    return cmd.toString()
}

// ... (imports e outras fun√ß√µes) ...


// Utilit√°rio para pegar dimens√µes da imagem
fun obterDimensoesImagem(path: String): Pair<Int, Int>? {
    return try {
        val options = BitmapFactory.Options().apply { inJustDecodeBounds = true }
        BitmapFactory.decodeFile(path, options)
        Pair(options.outWidth, options.outHeight)
    } catch (e: Exception) {
        null
    }
}


fun gerarZoompanExpressao(
    imgCaminho: String,
    larguraVideo: Int,
    alturaVideo: Int,
    frames: Int,
    cenaIdx: Int = -1
): Triple<String, String, String> {
    val (larguraImg, alturaImg) = obterDimensoesImagem(imgCaminho) ?: (1 to 1) // Evita zero!
    
    val escalaX =  larguraVideo.toDouble() / larguraImg.toDouble()
    val escalaY =  alturaVideo.toDouble() / alturaImg.toDouble() 
    val zoomAjuste = minOf(escalaX, escalaY)
    val larguraAjuste = larguraImg.toDouble() * zoomAjuste
    val alturaAjuste = alturaImg.toDouble() * zoomAjuste
    val escalaX1 = larguraVideo.toDouble() / larguraAjuste.toDouble() 
    val escalaY1 = alturaVideo.toDouble() / alturaAjuste.toDouble()
    val zoomFixo = maxOf(escalaX1, escalaY1)
    val zoom = zoomFixo
    var padX = (((larguraAjuste*zoomFixo)-larguraAjuste)/2)
    var padY = (((alturaAjuste*zoomFixo)-alturaAjuste)/2)

    var xExpr = "'$padX'"
    var yExpr = "'$padY'"
    
    if (larguraAjuste <= larguraVideo && alturaAjuste < alturaVideo){
        var t = padX 
        xExpr = "'($t-(($t/$frames)*on))'"
    }
    if (larguraAjuste < larguraVideo && alturaAjuste <= alturaVideo){
        var t = padY
        yExpr = "'($t-(($t/$frames)*on))'"
    }      

    val zoomExpr = "'$zoom + ((on * ($frames - 1 - on) / (($frames - 1) / 2))/1000)'"

    Log.i(TAG, "Cena $cenaIdx - Img: ${larguraImg}x${alturaImg} | Video: ${larguraVideo}x${alturaVideo}")
    Log.i(TAG, "Cena $cenaIdx - escalaX: $escalaX | escalaY: $escalaY | zoomAjuste: $zoomAjuste")
    Log.i(TAG, "Cena $cenaIdx - larguraAjuste: $larguraAjuste | alturaAjuste: $alturaAjuste")
    Log.i(TAG, "Cena $cenaIdx - escalaX1: $escalaX1 | escalaY1: $escalaY1 | zoomFixo: $zoomFixo")
    Log.i(TAG, "Cena $cenaIdx - xExpr: $xExpr | yExpr: $yExpr | zoom: $zoom")

    return Triple(zoomExpr, xExpr, yExpr)
}



    private fun copiarFonteParaCache(context: Context, nomeFonte: String): String {
        val assetPath = "fonts/$nomeFonte"
        val outFile = File(context.cacheDir, nomeFonte)
        if (!outFile.exists() || outFile.length() == 0L) {
            Log.d(TAG,"Copiando fonte '$nomeFonte' para o cache: ${outFile.absolutePath}")
            try {
                context.cacheDir.mkdirs()
                context.assets.open(assetPath).use { inputStream ->
                    outFile.outputStream().use { outputStream ->
                        inputStream.copyTo(outputStream)
                    }
                }
                if (!outFile.exists() || outFile.length() == 0L) {
                    throw RuntimeException("Arquivo da fonte n√£o foi criado ou est√° vazio ap√≥s a c√≥pia.")
                }
                Log.i(TAG,"Fonte '$nomeFonte' copiada com sucesso para ${outFile.absolutePath}")
            } catch (e: Exception) {
                Log.e(TAG, "Erro ao copiar fonte '$nomeFonte' do asset '$assetPath' para '${outFile.absolutePath}': ${e.message}", e)
                throw RuntimeException("Falha ao copiar fonte necess√°ria '$nomeFonte': ${e.message}", e)
            }
        } else {
            Log.d(TAG,"Fonte '$nomeFonte' j√° existe no cache: ${outFile.absolutePath}")
        }
        return outFile.absolutePath
    }

    private fun getProjectSpecificDirectory(context: Context, projectDirName: String, subDir: String): File? { // Retorna nullable agora
        val baseAppDir: File?
        if (projectDirName.isNotBlank()) {
            baseAppDir = context.getExternalFilesDir(null)
            if (baseAppDir != null) {
                val projectPath = File(baseAppDir, projectDirName)
                val finalDir = File(projectPath, subDir)
                if (!finalDir.exists() && !finalDir.mkdirs()) {
                    Log.e(TAG, "Falha ao criar diret√≥rio do projeto (externo): ${finalDir.absolutePath}")
                    return null // Retorna null em caso de falha na cria√ß√£o
                }
                return finalDir
            } else {
                Log.w(TAG, "Armazenamento externo para v√≠deos n√£o dispon√≠vel. Usando fallback para armazenamento interno para o projeto '$projectDirName'.")
                val internalProjectPath = File(context.filesDir, projectDirName)
                val finalInternalDir = File(internalProjectPath, subDir)
                 if (!finalInternalDir.exists() && !finalInternalDir.mkdirs()) {
                     Log.e(TAG, "Falha ao criar diret√≥rio interno do projeto (fallback A): ${finalInternalDir.absolutePath}")
                     return null // Retorna null em caso de falha na cria√ß√£o
                 }
                return finalInternalDir
            }
        }
        val defaultParentDirName = "video_editor_default"
        Log.w(TAG, "Nome do diret√≥rio do projeto para v√≠deos est√° em branco. Usando diret√≥rio de fallback interno: '$defaultParentDirName/$subDir'")
        val fallbackDir = File(File(context.filesDir, defaultParentDirName), subDir)
        if (!fallbackDir.exists() && !fallbackDir.mkdirs()) {
            Log.e(TAG, "Falha ao criar diret√≥rio de fallback interno: ${fallbackDir.absolutePath}")
            return null // Retorna null em caso de falha na cria√ß√£o
        }
        return fallbackDir
    }


    private fun createOutputFilePath(context: Context, prefix: String, projectDirName: String): String {
        val subDiretorioVideos = "edited_videos"
        val outputDir = getProjectSpecificDirectory(context, projectDirName, subDiretorioVideos)
            ?: File(context.cacheDir, "edited_videos_fallback") // Fallback para cacheDir se a cria√ß√£o falhar
        if (!outputDir.exists()) outputDir.mkdirs() // Tenta criar novamente se o fallback n√£o existir
        
        val timestamp = System.currentTimeMillis()
        val filename = "${prefix}_${timestamp}.mp4"
        val outputFile = File(outputDir, filename)
        return outputFile.absolutePath.also {
            Log.d(TAG, "üìÑ Caminho do arquivo de sa√≠da definido para v√≠deo: $it")
        }
    }

    class VideoGenerationException(message: String) : Exception(message)    
    // Definindo Octuple para acomodar os novos par√¢metros
    private data class Octuple<A, B, C, D, E, F, G, H>(val first: A, val second: B, val third: C, val fourth: D, val fifth: E, val sixth: F, val seventh: G, val eighth: H)
}