package com.carlex.euia.viewmodel

import android.app.Application
import android.content.Context
import android.content.Intent
import android.util.Base64
import android.util.Log
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.carlex.euia.R
import com.carlex.euia.BuildConfig
import com.carlex.euia.data.User // Usará os nomes ofuscados
import com.google.android.gms.auth.GoogleAuthUtil
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.common.api.Scope
import com.google.firebase.Timestamp
import com.google.firebase.auth.AuthCredential
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseUser
import com.google.firebase.auth.GoogleAuthProvider
import com.google.firebase.firestore.FieldValue
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext
import java.util.Calendar
import java.util.Date
import java.util.concurrent.TimeUnit
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec
import java.security.Key
import java.io.IOException
import java.security.NoSuchAlgorithmException
import javax.crypto.NoSuchPaddingException
import javax.crypto.BadPaddingException
import javax.crypto.IllegalBlockSizeException
import java.security.InvalidKeyException

enum class TaskType(val cost: Long) {
    TEXT_STANDARD(1),
    TEXT_PRO(5),
    AUDIO_SINGLE(10),
    AUDIO_MULTI(20),
    IMAGE(10)
}

class AuthViewModel(application: Application) : AndroidViewModel(application) {

    private val TAG = "AuthViewModel"
    
    private val appContext: Context = application.applicationContext



    // --- Instâncias de Serviços ---
    private val auth: FirebaseAuth = FirebaseAuth.getInstance()
    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance()

    private val googleSignInClient: GoogleSignInClient

    // --- Chaves e Nomes de Campos Remotos (Lidos do BuildConfig) ---
    private val REMOTE_COLLECTION_IDENTITY: String = BuildConfig.FIREBASE_COLLECTION_USERS
    private val REMOTE_FIELD_LOG_AMOUNT_ENCRYPTED: String = BuildConfig.FIREBASE_FIELD_CREDITS
    private val REMOTE_FIELD_SECURITY_PROCESS_CODE: String = BuildConfig.FIREBASE_FIELD_VALIDATION_KEY
    private val REMOTE_FIELD_ACCESS_SCOPE: String = BuildConfig.FIREBASE_FIELD_IS_PREMIUM
    private val REMOTE_FIELD_PROCESS_EXPIRY: String = BuildConfig.FIREBASE_FIELD_CREDIT_EXPIRY

    // --- Chave Mestra de Processo (Lida do BuildConfig) ---
    private val CORE_PROCESS_KEY_VALUE: String = BuildConfig.CRYPTO_MASTER_KEY

    // --- ID da Autoridade Central (Lido do BuildConfig) ---
    val CENTRAL_IDENTITY_FILE_VALUE: String = BuildConfig.ADMIN_USER_ID

    // --- Google Sign-In Client ID (Lido do BuildConfig) ---
    private val GOOGLE_WEB_CLIENT_ID_VALUE: String = BuildConfig.GOOGLE_WEB_CLIENT_ID

    // --- Valores de Processo (Custos de Processos) (Lidos do BuildConfig) ---
    private val processValueMap: Map<TaskType, Long> = mapOf(
        TaskType.TEXT_STANDARD to BuildConfig.COST_TEXT_STANDARD.toLong(),
        TaskType.TEXT_PRO to BuildConfig.COST_TEXT_PRO.toLong(),
        TaskType.AUDIO_SINGLE to BuildConfig.COST_AUDIO_SINGLE.toLong(),
        TaskType.AUDIO_MULTI to BuildConfig.COST_AUDIO_MULTI.toLong(),
        TaskType.IMAGE to BuildConfig.COST_IMAGE.toLong()
    )
    private val INITIAL_PROCESS_AMOUNT_VALUE: Long = BuildConfig.COST_FREE_CREDITS.toLong()


    // --- Escopos OAuth do Google ---
    companion object {
        const val YOUTUBE_UPLOAD_SCOPE = "https://www.googleapis.com/auth/youtube.upload"
    }

    // --- Estados ---
    private val _appIdentity = MutableStateFlow<FirebaseUser?>(null)
    val currentUser: StateFlow<FirebaseUser?> = _appIdentity.asStateFlow()

    private val _remoteProfileData = MutableStateFlow<User?>(null)
    val userProfile: StateFlow<User?> = _remoteProfileData.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _uiEvent = MutableSharedFlow<String>()
    val uiEvent: SharedFlow<String> = _uiEvent.asSharedFlow()

    private val _googleApiToken = MutableStateFlow<String?>(null)
    val youtubeAccessToken: StateFlow<String?> = _googleApiToken.asStateFlow()

    // --- Código de Processo de Segurança Derivado (Gerado no Cliente) ---
    private val _securityProcessCode = MutableStateFlow<String?>(null)
    private val securityProcessCode: StateFlow<String?> = _securityProcessCode.asStateFlow()

    // --- Saldo Descriptografado Seguro para UI ---
    private val _userDecryptedBalance = MutableStateFlow<Long?>(null)
    val userSafeBalanceForUI: StateFlow<Long?> = _userDecryptedBalance.asStateFlow()


    init {
        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
            .requestIdToken(GOOGLE_WEB_CLIENT_ID_VALUE)
            .requestEmail()
            .requestScopes(Scope(YOUTUBE_UPLOAD_SCOPE))
            .build()
        googleSignInClient = GoogleSignIn.getClient(application, gso)

        auth.addAuthStateListener { firebaseAuth ->
            val identity = firebaseAuth.currentUser
            _appIdentity.value = identity
            if (identity != null) {
                Log.e(TAG, "Identity ${identity.uid.takeLast(4)} logged in. Initializing process...")
                initializeProcessSession(identity)
            } else {
                _userDecryptedBalance.value = null
                _remoteProfileData.value = null
                _googleApiToken.value = null
                _securityProcessCode.value = null
                Log.e(TAG, "No identity logged in.")
            }
        }
    }

    /**
     * Inicializa o processo de sessão da identidade após login/registro.
     * Busca dados remotos, gera código de segurança local, verifica/salva no Firebase,
     * lida com renovação free, e carrega token Google.
     * Em caso de falhas críticas de segurança ou BD, pode deslogar a identidade.
     */
    private fun initializeProcessSession(identity: FirebaseUser) {
        viewModelScope.launch {
            val fileLogIdValue = identity.uid
            val remoteIdentityDocRef = firestore.collection(REMOTE_COLLECTION_IDENTITY).document(fileLogIdValue)

            val localGeneratedProcessCode = generateProcessSecurityCode(fileLogIdValue)
            _securityProcessCode.value = localGeneratedProcessCode
            if (localGeneratedProcessCode.isBlank()) {
                Log.e(TAG, "Critical failure: Local process security code generated is blank for identity ${fileLogIdValue.takeLast(4)}. Verify CORE_PROCESS_KEY in BuildConfig/local.properties.")
                _uiEvent.emit(appContext.getString(R.string.error_security_config_invalid))
                auth.signOut()
                return@launch
            }
            Log.e(TAG, "Local process security code successfully generated for identity ${fileLogIdValue.takeLast(4)}.")

            val remoteIdentitySnapshot = try {
                remoteIdentityDocRef.get().await()
            } catch (e: Exception) {
                Log.e(TAG, "Error fetching remote identity data for identity ${fileLogIdValue.takeLast(4)} from Firebase: ${e.message}", e)
                _uiEvent.emit(appContext.getString(R.string.error_db_fetch_profile))
                auth.signOut()
                return@launch
            }

            if (!remoteIdentitySnapshot.exists()) {
                Log.e(TAG, "Remote data not found for identity ${fileLogIdValue.takeLast(4)}. Creating new identity.")
                createNewRemoteIdentity(identity, localGeneratedProcessCode)
            } else {
                val remoteIdentityData = remoteIdentitySnapshot.toObject(User::class.java)
                if (remoteIdentityData == null) {
                    Log.e(TAG, "Failed to deserialize remote identity data for identity ${fileLogIdValue.takeLast(4)}.")
                    _uiEvent.emit(appContext.getString(R.string.error_db_read_profile))
                    auth.signOut()
                    return@launch
                }
                Log.e(TAG, "Remote data found and deserialized for identity ${fileLogIdValue.takeLast(4)}.")

                if (remoteIdentityData.codigoSegurancaRemoto.isNullOrBlank() || remoteIdentityData.codigoSegurancaRemoto != localGeneratedProcessCode) {
                    Log.e(TAG, "SEVERE SECURITY FAILURE - Remote process security code ('${remoteIdentityData.codigoSegurancaRemoto?.takeLast(4)}'...) is missing or incorrect for identity ${fileLogIdValue.takeLast(4)}. Local code: ('${localGeneratedProcessCode.takeLast(4)}'...)." )
                    _uiEvent.emit(appContext.getString(R.string.error_security_validation_failed))
                    auth.signOut()
                    return@launch
                }
                Log.e(TAG, "Process security code is OK for identity ${fileLogIdValue.takeLast(4)}.")

                if (!remoteIdentityData.escopoLog) {
                    val processExpiryDate = remoteIdentityData.dataUltimoLogin?.toDate()
                    val currentDate = Date()
                    if (processExpiryDate == null || currentDate.after(processExpiryDate)) {
                        Log.e(TAG, "Free process for identity ${fileLogIdValue.takeLast(4)} expired or never set. Renewing.")
                        val encryptedInitialProcessAmount = encrypt(localGeneratedProcessCode, INITIAL_PROCESS_AMOUNT_VALUE.toString())

                        if (encryptedInitialProcessAmount != null) {
                            val calendar = Calendar.getInstance()
                            calendar.time = currentDate
                            calendar.add(Calendar.HOUR, 24)
                            val newProcessExpiryTimestamp = Timestamp(calendar.time)

                            val updates = mapOf(
                                REMOTE_FIELD_LOG_AMOUNT_ENCRYPTED to encryptedInitialProcessAmount,
                                REMOTE_FIELD_PROCESS_EXPIRY to newProcessExpiryTimestamp
                            )
                            try {
                                remoteIdentityDocRef.update(updates).await()
                                Log.e(TAG, "Free process values renewed and saved encrypted for identity ${fileLogIdValue.takeLast(4)}. New expiry: $newProcessExpiryTimestamp")
                                _uiEvent.emit(appContext.getString(R.string.login_free_credits_renewed))
                            } catch (e: Exception) {
                                Log.e(TAG, "Error renewing and saving free process values for identity ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
                                _uiEvent.emit(appContext.getString(R.string.error_db_update_credits_renewal))
                            }
                        } else {
                            Log.e(TAG, "Failed to encrypt initial process values for identity ${fileLogIdValue.takeLast(4)}.")
                            _uiEvent.emit(appContext.getString(R.string.error_security_encryption_failed_generic))
                        }
                    }
                }

                val encryptedValue = remoteIdentityData.FileLogExperiencia
                val decryptedString = decrypt(localGeneratedProcessCode, encryptedValue ?: encrypt(localGeneratedProcessCode, "0")!!)
                _userDecryptedBalance.value = decryptedString?.toLongOrNull()
            }

            GoogleSignIn.getLastSignedInAccount(application)?.let { googleAccount ->
                viewModelScope.launch {
                    try {
                        val googleApiToken = getGoogleAccessToken(googleAccount, application)
                        _googleApiToken.value = googleApiToken
                    } catch (e: Exception) {
                        Log.e(TAG, "Error getting Google API Token: ${e.message}", e)
                        _uiEvent.emit(appContext.getString(R.string.error_google_oauth_token))
                    }
                }
            }
        }
    }

    /**
     * Cria uma nova identidade remota (documento de usuário) no Firestore com dados iniciais
     * (valores criptografados e código de processo de segurança).
     */
    private suspend fun createNewRemoteIdentity(identity: FirebaseUser, securityProcessCode: String) {
        val fileLogIdValue = identity.uid
        val encryptedInitialProcessAmount = encrypt(securityProcessCode, INITIAL_PROCESS_AMOUNT_VALUE.toString())

        if (encryptedInitialProcessAmount == null) {
            Log.e(TAG, "Failed to encrypt initial process values for the new identity ${fileLogIdValue.takeLast(4)}.")
            _uiEvent.emit(appContext.getString(R.string.error_security_initial_profile))
            auth.signOut()
            return
        }

        val calendar = Calendar.getInstance()
        calendar.add(Calendar.HOUR, 24)
        val initialProcessExpiry = Timestamp(calendar.time)

        val newUser = User(
            fileLogId = fileLogIdValue,
            emailUsuario = identity.email ?: "",
            nomeCompleto = identity.displayName,
            escopoLog = false,
            DataAtulizacaoUltimaVersao = null,
            FileLogExperiencia = encryptedInitialProcessAmount,
            dataUltimoLogin = initialProcessExpiry,
            codigoSegurancaRemoto = securityProcessCode,
            pontosExperiencia = 0
        )

        try {
            firestore.collection(REMOTE_COLLECTION_IDENTITY).document(fileLogIdValue).set(newUser).await()
            Log.e(TAG, "New remote identity created in Firebase for ${fileLogIdValue.takeLast(4)} with encrypted initial values.")
            _uiEvent.emit(appContext.getString(R.string.event_profile_created))
        } catch (e: Exception) {
            Log.e(TAG, "Error creating new remote identity in Firebase for ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
            _uiEvent.emit(appContext.getString(R.string.error_db_create_profile))
            auth.signOut()
        }
    }

    /**
     * Gera o código de processo de segurança combinando a chave mestra do BuildConfig
     * com o ID de log da identidade (UID).
     * Este código é usado para criptografia/descriptografia e verificação de integridade.
     * @param fileLogIdValue O ID de log da identidade (UID).
     * @return O código de processo de segurança gerado como String, ou uma string vazia
     *         se os componentes (chave mestra ou UID) forem inválidos.
     */
    private fun generateProcessSecurityCode(fileLogIdValue: String): String {
        val masterKey = CORE_PROCESS_KEY_VALUE

        if (fileLogIdValue.isBlank() || masterKey.isBlank()) {
            return ""
        }
        return "$masterKey-$fileLogIdValue"
    }

    /**
     * --- SIMULAÇÃO de Criptografia AES/ECB/PKCS5Padding ---
     * NOTA: Esta é APENAS uma simulação. PARA PRODUÇÃO, USE UMA BIBLIOTECA DE CRIPTOGRAFIA REAL E SEGURA.
     * ECB é DESENCORAJADO em cenários reais por não usar IV.
     * @param key O código de processo de segurança como String.
     * @param value O valor (ex: saldo como String) a ser criptografado.
     * @return O valor criptografado como String Base64 prefixada com "ENC:", ou null em caso de erro.
     */
    private fun encrypt(key: String, value: String): String? {
        return try {
            val aesKeyBytes = key.toByteArray(Charsets.UTF_8).copyOf(16)
            val secretKeySpec = SecretKeySpec(aesKeyBytes, "AES")
            val cipher = Cipher.getInstance("AES/ECB/PKCS5Padding")
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec)
            val encryptedBytes = cipher.doFinal(value.toByteArray(Charsets.UTF_8))
            "ENC:" + Base64.encodeToString(encryptedBytes, Base64.NO_WRAP)
        } catch (e: Exception) {
            Log.e(TAG, "Encryption Error: ${e.message}", e)
            null
        }
    }

    /**
     * --- SIMULAÇÃO de Descriptografia AES/ECB/PKCS5Padding ---
     * NOTA: Esta é APENAS uma simulação. PARA PRODUÇÃO, USE UMA BIBLIOTECA DE CRIPTOGRAFIA REAL E SEGURA.
     * Deve usar o mesmo algoritmo e padding da criptografia.
     * @param key O código de processo de segurança como String.
     * @param encryptedValue O valor criptografado como String Base64 prefixada com "ENC:".
     * @return O valor descriptografado como String, ou null em caso de erro ou valor inválido.
     */
    private fun decrypt(key: String, encryptedValue: String): String? {
        if (encryptedValue.isBlank() || !encryptedValue.startsWith("ENC:")) {
            return null
        }
        val base64Value = encryptedValue.removePrefix("ENC:")
        return try {
            val decodedBytes = Base64.decode(base64Value, Base64.DEFAULT)
            val aesKeyBytes = key.toByteArray(Charsets.UTF_8).copyOf(16)
            val secretKeySpec = SecretKeySpec(aesKeyBytes, "AES")
            val cipher = Cipher.getInstance("AES/ECB/PKCS5Padding")
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec)
            val decryptedBytes = cipher.doFinal(decodedBytes)
            String(decryptedBytes, Charsets.UTF_8)
        } catch (e: Exception) {
            Log.e(TAG, "Decryption Error: ${e.message}. Key ${key.takeLast(4)}... Value: ${encryptedValue.take(10)}...", e)
            null
        }
    }

    /**
     * Obtém o valor de processo (custo) de uma tarefa do BuildConfig (lido de local.properties).
     * @param TaskType O tipo de processo.
     * @return O valor de processo (custo) da tarefa como Long.
     */
    private fun getTaskProcessValue(TaskType: TaskType): Long {
        return processValueMap[TaskType] ?: run {
            Log.w(TAG, "Process value for TaskType ${TaskType.name} not found in BuildConfig map. Using default: ${TaskType.cost}.")
            TaskType.cost
        }
    }

    /**
     * Verifica se a identidade remota tem valores (saldo) suficientes para um processo (tarefa)
     * e os deduz.
     * Incorpora a validação do código de processo de segurança (codigoSegurancaRemoto) e
     * criptografia/descriptografia dos valores (FileLogExperiencia).
     *
     * Este método é a lógica central de transação de valores no cliente.
     *
     * @param TaskType O tipo de processo cujo valor será deduzido.
     * @return Result.success(Unit) se a dedução for bem-sucedida ou se a identidade remota
     *         tiver escopo "premium" (escopoLog = true).
     *         Result.failure(Exception) com mensagem de erro em caso de falha (valores insuficientes,
     *         erro de validação, erro de criptografia/descriptografia, erro no BD, etc.).
     */
    suspend fun checkAndDeductCredits(TaskType: TaskType): Result<Unit> = withContext(Dispatchers.IO) {
        val fileLogIdValue = auth.currentUser?.uid
        val processAmountRequired = getTaskProcessValue(TaskType)

        if (fileLogIdValue == null) {
            Log.e(TAG, "checkAndDeductCredits: Identity not logged in.")
            _uiEvent.emit(appContext.getString(R.string.error_user_not_logged_in))
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_user_not_logged_in)))
        }

        val localGeneratedProcessCode = securityProcessCode.value
        if (localGeneratedProcessCode.isNullOrBlank()) {
             Log.e(TAG, "checkAndDeductCredits: Local process security code not available for identity ${fileLogIdValue.takeLast(4)}. Session might not be initialized correctly.")
             _uiEvent.emit(appContext.getString(R.string.error_security_validation_failed))
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_security_validation_failed_generic)))
        }

        val remoteIdentityDocRef = firestore.collection(REMOTE_COLLECTION_IDENTITY).document(fileLogIdValue)
        val remoteIdentitySnapshot = try {
            remoteIdentityDocRef.get().await()
        } catch (e: Exception) {
             Log.e(TAG, "checkAndDeductCredits: Error fetching remote data for identity ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
             _uiEvent.emit(appContext.getString(R.string.error_db_fetch_profile))
             return@withContext Result.failure(Exception(appContext.getString(R.string.error_db_fetch_profile_generic)))
        }

        val remoteIdentityData = remoteIdentitySnapshot.toObject(User::class.java)

        if (remoteIdentityData == null) {
             Log.e(TAG, "checkAndDeductCredits: Remote data null/non-existent for identity ${fileLogIdValue.takeLast(4)}.")
             _uiEvent.emit(appContext.getString(R.string.error_profile_not_found))
             return@withContext Result.failure(Exception(appContext.getString(R.string.error_profile_not_found_generic)))
        }

        if (remoteIdentityData.codigoSegurancaRemoto.isNullOrBlank() || remoteIdentityData.codigoSegurancaRemoto != localGeneratedProcessCode) {
             Log.e(TAG, "checkAndDeductCredits: SEVERE SECURITY FAILURE - Remote process security code ('${remoteIdentityData.codigoSegurancaRemoto?.takeLast(4)}'...) is missing or incorrect for identity ${fileLogIdValue.takeLast(4)}. Local code: ('${localGeneratedProcessCode.takeLast(4)}'...)." )
             _uiEvent.emit(appContext.getString(R.string.error_security_validation_failed))
             auth.signOut()
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_security_validation_failed_generic)))
        }
        Log.e(TAG, "checkAndDeductCredits: Process security code is OK for identity ${fileLogIdValue.takeLast(4)}.")

        val encryptedProcessValue = remoteIdentityData.FileLogExperiencia
        val decryptedProcessValueString = decrypt(localGeneratedProcessCode, encryptedProcessValue ?: encrypt(localGeneratedProcessCode, "0")!!)

        if (decryptedProcessValueString == null) {
            Log.e(TAG, "checkAndDeductCredits: FALHA DE SEGURANÇA - Failed to decrypt process value for identity ${fileLogIdValue.takeLast(4)}. Data might be corrupt or key is wrong.")
            _uiEvent.emit(appContext.getString(R.string.error_security_decryption_failed))
            auth.signOut()
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_security_decryption_failed_generic)))
        }
        val currentProcessValue = decryptedProcessValueString.toLongOrNull()
        if (currentProcessValue == null) {
            Log.e(TAG, "checkAndDeductCredits: FALHA DE SEGURANÇA - Decrypted process value is not numeric: '$decryptedProcessValueString' for identity ${fileLogIdValue.takeLast(4)}.")
            _uiEvent.emit(appContext.getString(R.string.error_security_invalid_credits_format))
            auth.signOut()
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_security_invalid_credits_format_generic)))
        }
        Log.e(TAG, "checkAndDeductCredits: Process value (balance) decrypted: $currentProcessValue for identity ${fileLogIdValue.takeLast(4)}.")

        if (currentProcessValue < processAmountRequired) {
            val processExpiryDate = remoteIdentityData.dataUltimoLogin?.toDate()
            val timeRemainingMsg = if (processExpiryDate != null) {
                val diff = processExpiryDate.time - System.currentTimeMillis()
                if (diff > 0) {
                    val hours = TimeUnit.MILLISECONDS.toHours(diff)
                    val minutes = TimeUnit.MILLISECONDS.toMinutes(diff) % 60
                    appContext.getString(R.string.credits_expire_in, hours, minutes)
                } else {
                    appContext.getString(R.string.credits_expired_relogin)
                }
            } else {
                appContext.getString(R.string.credits_no_expiry_relogin)
            }
            val errorMsg = appContext.getString(R.string.error_insufficient_credits_needed_available, TaskType.name, processAmountRequired, currentProcessValue, timeRemainingMsg)
            Log.w(TAG, errorMsg)
            _uiEvent.emit(errorMsg)
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_insufficient_credits_generic)))
        }

        val updatedProcessValue = currentProcessValue - processAmountRequired
        val encryptedUpdatedProcessValue = encrypt(localGeneratedProcessCode, updatedProcessValue.toString())

        if (encryptedUpdatedProcessValue == null) {
            Log.e(TAG, "checkAndDeductCredits: FALHA DE SEGURANÇA - Failed to encrypt new process value ($updatedProcessValue) for identity ${fileLogIdValue.takeLast(4)}.")
            _uiEvent.emit(appContext.getString(R.string.error_security_encryption_failed))
            auth.signOut()
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_security_encryption_failed_generic)))
        }
        Log.e(TAG, "checkAndDeductCredits: New process value $updatedProcessValue encrypted. Updating Firebase for identity ${fileLogIdValue.takeLast(4)}.")

        try {
            remoteIdentityDocRef.update(REMOTE_FIELD_LOG_AMOUNT_ENCRYPTED, encryptedUpdatedProcessValue).await()
            Log.e(TAG, "checkAndDeductCredits: Process value deducted successfully for identity ${fileLogIdValue.takeLast(4)}. Estimated balance: $updatedProcessValue.")
            _userDecryptedBalance.value = updatedProcessValue // Update safe balance for UI
            _uiEvent.emit(appContext.getString(R.string.event_credits_deducted, processAmountRequired, updatedProcessValue))
            return@withContext Result.success(Unit)
        } catch (e: Exception) {
            Log.e(TAG, "checkAndDeductCredits: Error updating process value in Firebase for identity ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
            _uiEvent.emit(appContext.getString(R.string.error_db_update_credits_failed))
            return@withContext Result.failure(Exception(appContext.getString(R.string.error_db_update_credits_failed_generic)))
        }
    }

    /**
     * Adiciona o valor de volta para a identidade remota em caso de falha na tarefa.
     * @param TaskType O tipo de processo cujo valor será adicionado (reembolsado).
     */
    fun refundCredits(TaskType: TaskType) {
        val fileLogIdValue = auth.currentUser?.uid
        val amount = getTaskProcessValue(TaskType)

        if (fileLogIdValue == null) {
            Log.e(TAG, "refundCredits: Identity not logged in to refund values.")
            return
        }

        val localGeneratedProcessCode = securityProcessCode.value
        if (localGeneratedProcessCode.isNullOrBlank()) {
            Log.e(TAG, "refundCredits: Local process security code not available for refund. Refund not processed.")
            return
        }

        viewModelScope.launch(Dispatchers.IO) {
            val remoteIdentityDocRef = firestore.collection(REMOTE_COLLECTION_IDENTITY).document(fileLogIdValue)
            try {
                val remoteIdentitySnapshot = remoteIdentityDocRef.get().await()
                val remoteIdentityData = remoteIdentitySnapshot.toObject(User::class.java)

                if (remoteIdentityData == null || remoteIdentityData.codigoSegurancaRemoto.isNullOrBlank() || remoteIdentityData.codigoSegurancaRemoto != localGeneratedProcessCode) {
                    Log.e(TAG, "refundCredits: SEVERE SECURITY FAILURE - Remote data null, security code missing or incorrect in DB for refund of ${amount} values for identity ${fileLogIdValue.takeLast(4)}. Refund not processed.")
                    return@launch
                }
                Log.e(TAG, "refundCredits: Process security code is OK for refund for identity ${fileLogIdValue.takeLast(4)}.")

                val encryptedProcessValue = remoteIdentityData.FileLogExperiencia
                val currentProcessValue = decrypt(localGeneratedProcessCode, encryptedProcessValue ?: encrypt(localGeneratedProcessCode, "0")!!)?.toLongOrNull() ?: 0L

                val updatedProcessValue = currentProcessValue + amount
                val encryptedUpdatedProcessValue = encrypt(localGeneratedProcessCode, updatedProcessValue.toString())

                if (encryptedUpdatedProcessValue == null) {
                    Log.e(TAG, "refundCredits: FALHA DE SEGURANÇA - Failed to encrypt new value ($updatedProcessValue) for refund for identity ${fileLogIdValue.takeLast(4)}.")
                    return@launch
                }

                remoteIdentityDocRef.update(REMOTE_FIELD_LOG_AMOUNT_ENCRYPTED, encryptedUpdatedProcessValue).await()
                Log.e(TAG, "refundCredits: Refund of $amount values processed successfully for identity ${fileLogIdValue.takeLast(4)}. Estimated balance: $updatedProcessValue.")
                _userDecryptedBalance.value = updatedProcessValue // Update safe balance for UI
                _uiEvent.emit(appContext.getString(R.string.event_credits_refunded, amount, updatedProcessValue))

            } catch (e: Exception) {
                Log.e(TAG, "refundCredits: Error fetching remote data or updating value for refund for identity ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
                _uiEvent.emit(appContext.getString(R.string.error_db_update_credits_refund))
            }
        }
    }

    /**
     * Busca o token de acesso OAuth do Google para o escopo do YouTube.
     * @param account A conta GoogleSignInAccount logada.
     * @param context Contexto da aplicação.
     * @return O token de acesso como String, ou null em caso de falha.
     */
    private suspend fun getGoogleAccessToken(account: GoogleSignInAccount, context: Context): String? = withContext(Dispatchers.IO) {
        val email = account.email
        if (email.isNullOrBlank()) {
            Log.e(TAG, "getGoogleAccessToken: GoogleSignInAccount.email is null or blank!")
            return@withContext null
        }
        return@withContext try {
            GoogleAuthUtil.getToken(
                context,
                email,
                "oauth2:$YOUTUBE_UPLOAD_SCOPE"
            )
        } catch (e: Exception) {
            Log.e(TAG, "getGoogleAccessToken: Error getting Google OAuth Token: ${e.localizedMessage}", e)
            null
        }
    }

    /**
     * Inicia o fluxo de login do Google.
     * Retorna a Intent a ser passada para o ActivityResultLauncher.
     */
    fun getGoogleSignInIntent(): Intent {
        return googleSignInClient.signInIntent
    }

    /**
     * Lida com o resultado do ActivityResult do login do Google.
     * Extrai o ID Token e Access Token e tenta autenticar no Firebase.
     */
    fun handleGoogleSignInResult(data: Intent?) {
        _isLoading.value = true
        _uiEvent.value = ""
        viewModelScope.launch {
            try {
                val task = GoogleSignIn.getSignedInAccountFromIntent(data)
                val account = task.getResult(ApiException::class.java)
                val idToken = account.idToken
                if (idToken != null) {
                    val googleApiToken = getGoogleAccessToken(account, getApplication())
                    val credential = GoogleAuthProvider.getCredential(idToken, null)
                    signInWithFirebaseAndGoogle(credential, googleApiToken)
                } else {
                    Log.e(TAG, "handleGoogleSignInResult: Google ID Token is null after apparent success.")
                    _uiEvent.emit(appContext.getString(R.string.error_google_signin_failed_id_token))
                    _isLoading.value = false
                }
            } catch (e: ApiException) {
                val errorMsg = appContext.getString(R.string.error_google_signin_api_error, e.statusCode, e.message)
                Log.e(TAG, "handleGoogleSignInResult: API Error: $errorMsg", e)
                _uiEvent.emit(errorMsg)
                _isLoading.value = false
            } catch (e: Exception) {
                val errorMsg = appContext.getString(R.string.error_google_signin_generic, e.localizedMessage)
                Log.e(TAG, "handleGoogleSignInResult: Generic Error: $errorMsg", e)
                _uiEvent.emit(errorMsg)
                _isLoading.value = false
            }
        }
    }

    /**
     * Autentica no Firebase usando a credencial do Google e inicializa a sessão.
     * Se a autenticação for bem-sucedida, o authStateListener irá detectar e iniciar a sessão.
     */
    private suspend fun signInWithFirebaseAndGoogle(credential: AuthCredential, googleApiToken: String?) {
        try {
            val authResult = auth.signInWithCredential(credential).await()
            val firebaseIdentity = authResult.user

            if (firebaseIdentity != null) {
                Log.e(TAG, "signInWithFirebaseAndGoogle: Google via Firebase login SUCCESS for identity ${firebaseIdentity.uid.takeLast(4)}.")
            } else {
                Log.e(TAG, "signInWithFirebaseAndGoogle: Firebase authResult.user is null.")
                _uiEvent.emit(appContext.getString(R.string.error_firebase_signin_null_user))
            }
        } catch (e: Exception) {
            val errorMsg = appContext.getString(R.string.error_firebase_signin_credential, e.localizedMessage)
            Log.e(TAG, "signInWithFirebaseAndGoogle: Error: $errorMsg", e)
            _uiEvent.emit(errorMsg)
        } finally {
            _isLoading.value = false
        }
    }

    /**
     * Registra uma nova identidade com email e senha no Firebase Auth.
     * Se o registro for bem-sucedido, o authStateListener irá iniciar a sessão.
     */
    fun register(email: String, password: String) {
        _isLoading.value = true
        _uiEvent.value = ""
        viewModelScope.launch {
            try {
                val result = auth.createUserWithEmailAndPassword(email, password).await()
                val firebaseIdentity = result.user
                if (firebaseIdentity != null) {
                    Log.e(TAG, "Identity successfully registered with email/password for ${firebaseIdentity.uid.takeLast(4)}.")
                } else {
                    Log.e(TAG, "register: Firebase authResult.user is null.")
                    _uiEvent.emit(appContext.getString(R.string.error_firebase_register_null_user))
                }
            } catch (e: Exception) {
                val errorMsg = appContext.getString(R.string.error_firebase_register_generic, e.localizedMessage)
                Log.e(TAG, "register: Error: $errorMsg", e)
                _uiEvent.emit(errorMsg)
            } finally {
                _isLoading.value = false
            }
        }
    }

    /**
     * Realiza o login com email e senha no Firebase Auth.
     * Se o login for bem-sucedido, o authStateListener irá iniciar a sessão.
     */
    fun login(email: String, password: String) {
        _isLoading.value = true
        _uiEvent.value = ""
        viewModelScope.launch {
            try {
                val authResult = auth.signInWithEmailAndPassword(email, password).await()
                val firebaseIdentity = authResult.user
                if (firebaseIdentity != null) {
                    Log.e(TAG, "login: Login with email/password SUCCESS for identity ${firebaseIdentity.uid.takeLast(4)}.")
                } else {
                    Log.e(TAG, "login: Firebase authResult.user is null.")
                    _uiEvent.emit(appContext.getString(R.string.error_firebase_login_null_user))
                }
            } catch (e: Exception) {
                val errorMsg = appContext.getString(R.string.error_firebase_login_generic, e.localizedMessage)
                Log.e(TAG, "login: Error: $errorMsg", e)
                _uiEvent.emit(errorMsg)
            } finally {
                _isLoading.value = false
            }
        }
    }

    /**
     * Realiza o logout da identidade no Firebase Auth e Google Sign-In (se aplicável).
     * A limpeza de estados (@StateFlows) é feita pelo authStateListener.
     */
    fun logout() {
        viewModelScope.launch {
            try {
                if (GoogleSignIn.getLastSignedInAccount(getApplication()) != null) {
                    googleSignInClient.signOut().await()
                    Log.e(TAG, "Logged out from Google Sign-In.")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error logging out from Google Sign-In: ${e.message}", e)
            } finally {
                auth.signOut()
                Log.e(TAG, "Identity logged out from Firebase Auth.")
                _uiEvent.emit(appContext.getString(R.string.event_logout_success))
            }
        }
    }

    /**
     * Envia email para resetar a senha de uma identidade.
     * @param email O email da identidade para resetar a senha.
     */
    fun resetPassword(email: String) {
        _isLoading.value = true
        _uiEvent.value = ""
        viewModelScope.launch {
            try {
                auth.sendPasswordResetEmail(email).await()
                Log.e(TAG, "resetPassword: Password reset email sent to: $email")
                _uiEvent.emit(appContext.getString(R.string.login_password_reset_sent))
            } catch (e: Exception) {
                val errorMsg = appContext.getString(R.string.error_firebase_password_reset, e.localizedMessage)
                Log.e(TAG, "resetPassword: Error: $errorMsg", e)
                _uiEvent.emit(errorMsg)
            } finally {
                _isLoading.value = false
            }
        }
    }

    /**
     * Atualiza o status de escopo (premium) de uma identidade remota no Firestore.
     * Esta função pode ser chamada por lógica de faturamento (BillingViewModel).
     * Usa nomes de campos lidos do BuildConfig ao atualizar o armazenamento remoto.
     * @param fileLogIdValue O ID de log da identidade a ser atualizada.
     * @param isPremium O novo status de escopo (true/false).
     * @param subscriptionEndDate A data de fim da assinatura em milissegundos (opcional).
     */
    fun updatePremiumStatus(fileLogIdValue: String, isPremium: Boolean, subscriptionEndDate: Long? = null) {
        viewModelScope.launch(Dispatchers.IO) {
            try {
                val remoteIdentityDocRef = firestore.collection(REMOTE_COLLECTION_IDENTITY).document(fileLogIdValue)
                val updates = mutableMapOf<String, Any>(
                    REMOTE_FIELD_ACCESS_SCOPE to isPremium
                )
                if (subscriptionEndDate != null) {
                    updates["subscriptionEndDate"] = subscriptionEndDate
                } else {
                    updates["subscriptionEndDate"] = FieldValue.delete()
                }
                remoteIdentityDocRef.update(updates).await()
                Log.e(TAG, "updatePremiumStatus: Scope status updated for identity ${fileLogIdValue.takeLast(4)}: Premium: $isPremium")
            } catch (e: Exception) {
                Log.e(TAG, "updatePremiumStatus: Error updating scope status for identity ${fileLogIdValue.takeLast(4)}: ${e.message}", e)
            }
        }
    }

    /**
     * Verifica se a identidade atualmente logada é a identidade da autoridade central (admin).
     * Usa o ID de log da identidade logada (fileLogId) e o ID da autoridade central lido do BuildConfig.
     * @return True se a identidade logada for a autoridade central (admin), false caso contrário.
     */
    fun isCurrentUserAdmin(): Boolean {
        return _appIdentity.value?.fileLogId == CENTRAL_IDENTITY_FILE_VALUE
    }

    /**
     * Limpa o StateFlow de eventos da UI.
     * Note: Este método é menos relevante para SharedFlow, que gerencia a entrega de eventos.
     * Mantido para clareza do propósito de resetar mensagens se necessário na UI.
     */
    fun clearUiEvent() {
        // Para SharedFlow, os eventos são consumidos uma vez.
        // Se precisar de um "reset" de estado de erro/mensagem,
        // a UI coletora ou outro StateFlow pode ser mais adequado.
        // Para este SharedFlow, este método não tem efeito direto na entrega.
    }
}